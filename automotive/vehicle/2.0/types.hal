/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.automotive.vehicle@2.0;

/**
 * Enumerates supported data types for VehicleProperty.
 *
 * This is a bitwise flag that supposed to be used in VehicleProperty enum.
 */
enum VehiclePropertyType : int32_t {
    STRING         = 0x00100000,
    BOOLEAN        = 0x00200000,
    INT32          = 0x00400000,
    INT32_VEC      = 0x00410000,
    INT64          = 0x00500000,
    INT64_VEC      = 0x00510000,
    FLOAT          = 0x00600000,
    FLOAT_VEC      = 0x00610000,
    BYTES          = 0x00700000,

    /**
     * Any combination of scalar or vector types. The exact format must be
     * provided in the description of the property.
     */
    MIXED          = 0x00e00000,

    MASK           = 0x00ff0000
};

/**
 * Some properties may be associated with particular vehicle areas. For
 * example, VehicleProperty:DOOR_LOCK property must be associated with
 * particular door, thus this property must be marked with
 * VehicleArea:DOOR flag.
 *
 * Other properties may not be associated with particular vehicle area,
 * these kind of properties must have VehicleArea:GLOBAL flag.
 *
 * This is a bitwise flag that supposed to be used in VehicleProperty enum.
 */
enum VehicleArea : int32_t {
      GLOBAL       = 0x01000000,
      ZONE         = 0x02000000,
      WINDOW       = 0x03000000,
      MIRROR       = 0x04000000,
      SEAT         = 0x05000000,
      DOOR         = 0x06000000,

      MASK         = 0x0f000000,
};

/**
 * Enumerates property groups.
 *
 * This is a bitwise flag that supposed to be used in VehicleProperty enum.
 */
enum VehiclePropertyGroup : int32_t {
    /**
     * Properties declared in AOSP must have this flag.
     */
    SYSTEM         = 0x10000000,

    /**
     * Properties declared by vendors must have this flag.
     */
    VENDOR         = 0x20000000,

    MASK           = 0xf0000000,
};

/**
 * Declares all vehicle properties. VehicleProperty has a bitwise structure.
 * Each property must have:
 *   - an unique id from range 0x0100 - 0xffff
 *   - associated data type using VehiclePropertyType
 *   - property group (VehiclePropertyGroup)
 *   - vehicle area (VehicleArea)
 *
 * Vendors are allowed to extend this enum with their own properties. In this
 * case they must use VehiclePropertyGroup:VENDOR flag when property is
 * declared.
 */
enum VehicleProperty: int32_t {

    /** Undefined property. */
    INVALID = 0x00000000,

    /**
     * VIN of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_VIN= (
        0x0100
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Maker name of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_MAKE = (
        0x0101
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Model of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_MODEL = (
        0x0102
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),

    /**
     * Model year of vehicle.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:YEAR
     */
    INFO_MODEL_YEAR = (
        0x0103
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Fuel capacity of the vehicle in milliliters
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MILLILITER
     */
    INFO_FUEL_CAPACITY = (
        0x0104
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * List of fuels the vehicle may use.  Uses enum FuelType
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MILLILITERS
     */
    INFO_FUEL_TYPE = (
        0x0105
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Battery capacity of the vehicle, if EV or hybrid.  This is the nominal
     * battery capacity when the vehicle is new.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:WH
     */
    INFO_EV_BATTERY_CAPACITY = (
        0x0106
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * List of connectors this EV may use.  Uses enum EvConnectorType
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_EV_CONNECTOR_TYPE = (
        0x0107
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Current odometer value of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE | VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:KILOMETER
     */
    PERF_ODOMETER = (
        0x0204
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Speed of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:METER_PER_SEC
     */
    PERF_VEHICLE_SPEED = (
        0x0207
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Engine on
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    ENGINE_ON = (
        0x0300
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),


    /**
     * Temperature of engine coolant
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENGINE_COOLANT_TEMP = (
        0x0301
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Engine oil level
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleOilLevel
     */
    ENGINE_OIL_LEVEL = (
        0x0303
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Temperature of engine oil
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENGINE_OIL_TEMP = (
        0x0304
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Engine rpm
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:RPM
     */
    ENGINE_RPM = (
        0x0305
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Reports wheel ticks
     *
     * The first four elements represent ticks for individual wheels in the
     * following order: front left, front right, rear right, rear left.  All
     * tick counts are cumulative.  Tick counts increment when the vehicle
     * moves forward, and decrement when vehicles moves in reverse.  The ticks
     * should be reset to 0 when the vehicle is started by the user.
     *
     * The next element in the vector is a reset count.  A reset indicates
     * previous tick counts are not comparable with this and future ones.  Some
     * sort of discontinuity in tick counting has occurred.
     *
     *  int64Values[0] = reset count
     *  int64Values[1] = front left ticks
     *  int64Values[2] = front right ticks
     *  int64Values[3] = rear right ticks
     *  int64Values[4] = rear left ticks
     *
     * configArray is used to indicate the micrometers-per-wheel-tick value as well as
     * which wheels are supported.  configArray is set as follows:
     *
     *  configArray[0], bits [0:3] = supported wheels.  Uses enum Wheel.
     *  configArray[1] = micrometers per front left wheel tick
     *  configArray[2] = micrometers per front right wheel tick
     *  configArray[3] = micrometers per rear right wheel tick
     *  configArray[4] = micrometers per rear left wheel tick
     *
     * NOTE:  If a wheel is not supported, its value shall always be set to 0.
     *
     * VehiclePropValue.timestamp must be correctly filled in.
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     */
    WHEEL_TICK = (
      0x0306
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:MIXED
      | VehicleArea:GLOBAL),


    /**
     * Fuel remaining in the the vehicle, in milliliters
     *
     * Value may not exceed INFO_FUEL_CAPACITY
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MILLILITER
     */
    FUEL_LEVEL = (
        0x0307
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Fuel door open
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    FUEL_DOOR_OPEN = (
        0x0308
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * EV battery level in WH, if EV or hybrid
     *
     * Value may not exceed INFO_EV_BATTERY_CAPACITY
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:WH
     */
    EV_BATTERY_LEVEL = (
        0x0309
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * EV charge port open
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    EV_CHARGE_PORT_OPEN = (
        0x030A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * EV charge port connected
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    EV_CHARGE_PORT_CONNECTED = (
        0x030B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * EV instantaneous charge rate in milliwatts
     *
     * Positive value indicates battery is being charged.
     * Negative value indicates battery being discharged.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MW
     */
    EV_BATTERY_INSTANTANEOUS_CHARGE_RATE = (
        0x030C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Currently selected gear
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleGear
     */
    GEAR_SELECTION = (
        0x0400
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Current gear. In non-manual case, selected gear does not necessarily
     * match the current gear.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleGear
     */
    CURRENT_GEAR = (
        0x0401
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Parking brake state.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    PARKING_BRAKE_ON = (
        0x0402
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Auto-apply parking brake.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    PARKING_BRAKE_AUTO_APPLY = (
        0x0403
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Driving status policy.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleDrivingStatus
     */
    DRIVING_STATUS = (
        0x0404
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Warning for fuel low level.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    FUEL_LEVEL_LOW = (
        0x0405
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Night mode or not.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    NIGHT_MODE = (
        0x0407
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * State of the vehicles turn signals
     *
     * Values from VehicleTurnSignal
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    TURN_SIGNAL_STATE = (
        0x0408
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Represents ignition state
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    IGNITION_STATE = (
        0x0409
            | VehiclePropertyGroup:SYSTEM
            | VehiclePropertyType:INT32
            | VehicleArea:GLOBAL),

    /**
     * ABS is active.  Set to true whenever ABS is activated.  Reset to false when ABS is off.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    ABS_ACTIVE = (
        0x040A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Traction Control is active.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    TRACTION_CONTROL_ACTIVE = (
        0x040B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Fan speed setting
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_FAN_SPEED = (
        0x0500
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Fan direction setting
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleHvacFanDirection
     */
    HVAC_FAN_DIRECTION = (
        0x0501
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * HVAC current temperature.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_TEMPERATURE_CURRENT = (
        0x0502
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:ZONE),

    /**
     * HVAC, target temperature set.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_TEMPERATURE_SET = (
        0x0503
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:ZONE),

    /**
     * On/off defrost
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_DEFROSTER = (
        0x0504
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:WINDOW),

    /**
     * On/off AC
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags Supported zones
     */
    HVAC_AC_ON = (
        0x0505
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off max AC
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_MAX_AC_ON = (
        0x0506
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off max defrost
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_MAX_DEFROST_ON = (
        0x0507
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off re-circulation
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_RECIRC_ON = (
        0x0508
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off dual. This must be defined per each row.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_DUAL_ON = (
        0x0509
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * On/off automatic mode
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_AUTO_ON = (
        0x050A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * Seat temperature
     *
     * Negative values indicate cooling.
     * 0 indicates off.
     * Positive values indicate heating.
     *
     * Some vehicles may have multiple levels of heating and cooling. The
     * min/max range defines the allowable range and number of steps in each
     * direction.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_SEAT_TEMPERATURE = (
        0x050B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Side Mirror Heat
     *
     * Increase values denote higher heating levels for side mirrors.
     * 0 indicates heating is turned off.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_SIDE_MIRROR_HEAT = (
        0x050C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Steering Wheel Temperature
     *
     * Sets the temperature for the steering wheel
     * Positive value indicates heating.
     * Negative value indicates cooling.
     * 0 indicates temperature control is off.
     *
     * IVehicle#set may return StatusCode::NOT_AVAILABLE and IVehicle#get is not
     * guaranteed to work if HVAC unit is off.  See HVAC_POWER_ON property for
     * details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_STEERING_WHEEL_TEMP = (
        0x050D
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Temperature units
     *
     * Indicates whether the temperature is in Celsius, Fahrenheit, or a
     * different unit from VehicleUnit enum.
     * This parameter affects all HVAC temperatures in the system.
     *
     * IVehicle#get is not guaranteed to work if HVAC unit is off.  See
     * HVAC_POWER_ON property for details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    HVAC_TEMPERATURE_UNITS = (
        0x050E
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Actual fan speed
     *
     * IVehicle#get is not guaranteed to work if HVAC unit is off.  See
     * HVAC_POWER_ON property for details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    HVAC_ACTUAL_FAN_SPEED_RPM = (
        0x050F
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:ZONE),

    /**
     * Represents power state for HVAC. Some HVAC properties must require
     * matching power to be turned on to get out of OFF state. For non-zoned
     * HVAC properties, VEHICLE_ALL_ZONE corresponds to global power state.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_string list of HVAC properties whose power is controlled by this
     *                property. Format is hexa-decimal number (0x...) separated
     *                by comma like "0x500,0x503". All zones defined in these
     *                affected properties must be available in the property.
     */
    HVAC_POWER_ON = (
        0x0510
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * Fan Positions Available
     *
     * This is a bit mask of fan positions available for the zone.  Each available fan direction is
     * denoted by a separate entry in the vector.  A fan direction may have multiple bits from
     * vehicle_hvac_fan_direction set.  For instance, a typical car may have the following setting:
     *   - [0] = FAN_DIRECTION_FACE (0x1)
     *   - [1] = FAN_DIRECTION_FLOOR (0x2)
     *   - [2] = FAN_DIRECTION_FACE | FAN_DIRECTION_FLOOR (0x3)
     *   - [3] = FAN_DIRECTION_DEFROST (0x4)
     *   - [4] = FAN_DIRECTION_FLOOR | FAN_DIRECTION_DEFROST (0x6)
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    HVAC_FAN_DIRECTION_AVAILABLE = (
        0x0511
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:ZONE),

    /**
     * Automatic re-circulation on/off
     *
     * IVehicle#set and IVehicle#get must return StatusCode::NOT_AVAILABLE when HVAC unit is off.
     * See HVAC_POWER_ON property for details.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_AUTO_RECIRC_ON = (
        0x0512
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:ZONE),

    /**
     * Outside temperature
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENV_OUTSIDE_TEMPERATURE = (
        0x0703
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Cabin temperature
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE|VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENV_CABIN_TEMPERATURE = (
        0x0704
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),

    /**
     * Radio presets stored on the Car radio module. The data type used is int32
     * array with the following fields:
     * <ul>
     *    <li> int32Values[0]: Preset number </li>
     *    <li> int32Values[1]: Band type (see #RADIO_BAND_FM in
     *    system/core/include/system/radio.h).
     *    <li> int32Values[2]: Channel number </li>
     *    <li> int32Values[3]: Sub channel number </li>
     * </ul>
     *
     * NOTE: When getting a current preset config ONLY set preset number (i.e.
     * int32Values[0]). For setting a preset other fields are required.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags Number of presets supported
     */
    RADIO_PRESET = (
        0x0801
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to control power state of application processor
     *
     * It is assumed that AP's power state is controller by separate power
     * controller.
     *
     * For configuration information, VehiclePropConfig.configFlags can
     * have bit flag combining values in VehicleApPowerStateConfigFlag.
     *
     * Value format for IVehicle#get / IVehicle#subscribe:
     *   int32Values[0] : vehicle_ap_power_state_type
     *   int32Values[1] : additional parameter relevant for each state,
     *                    0 if not used.
     * Value format for IVehicle#set:
     *   int32Values[0] : vehicle_ap_power_state_set_type
     *   int32Values[1] : additional parameter relevant for each request. should be 0 if not used.
     *
     * @change_mode VEHICLE_PROP_CHANGE_MODE_ON_CHANGE
     * @access VEHICLE_PROP_ACCESS_READ_WRITE
     */
    AP_POWER_STATE = (
        0x0A00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Property to represent brightness of the display. Some cars have single
     * control for the brightness of all displays and this property is to share
     * change in that control.
     *
     * If this is writable, android side can set this value when user changes
     * display brightness from Settings. If this is read only, user may still
     * change display brightness from Settings, but that will not be reflected
     * to other displays.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DISPLAY_BRIGHTNESS = (
        0x0A01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Property to report bootup reason for the current power on. This is a
     * static property that will not change for the whole duration until power
     * off. For example, even if user presses power on button after automatic
     * power on with door unlock, bootup reason must stay with
     * VehicleApPowerBootupReason#USER_UNLOCK.
     *
     * int32Values[0] must be VehicleApPowerBootupReason.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
    */
    AP_POWER_BOOTUP_REASON = (
        0x0A02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Property to feed H/W input events to android
     *
     * int32Values[0] : action defined by VehicleHwKeyInputAction
     * int32Values[1] : key code, must use standard android key code
     * int32Values[2] : target display defined in VehicleDisplay. Events not
     *                  tied to specific display must be sent to
     *                  VehicleDisplay#MAIN.
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @config_flags
     */
    HW_KEY_INPUT = (
        0x0A10
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),

    /**
     * Current date and time, encoded as Unix time.
     * This value denotes the number of seconds that have elapsed since
     * 1/1/1970.
     *
     * @change_mode VehiclePropertyChangeMode:ON_SET
     * @access VehiclePropertyAccess:READ_WRITE
     * @unit VehicleUnit:SECS
     */
    UNIX_TIME = (
        0x0A30
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT64
        | VehicleArea:GLOBAL),

    /**
     * Current time only.
     * Some vehicles may not keep track of date.  This property only affects
     * the current time, in seconds during the day.  Thus, the max value for
     * this parameter is 86,400 (24 * 60 * 60)
     *
     * @change_mode VehiclePropertyChangeMode:ON_SET
     * @access VehiclePropertyAccess:READ_WRITE
     * @unit VehicleUnit:SECS
     */
    CURRENT_TIME_IN_SECONDS = (
        0x0A31
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Door position
     *
     * This is an integer in case a door may be set to a particular position.
     * Max value indicates fully open, min value (0) indicates fully closed.
     *
     * Some vehicles (minivans) can open the door electronically.  Hence, the
     * ability to write this property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_POS = (
        0x0B00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:DOOR),

    /**
     * Door move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_MOVE = (
        0x0B01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:DOOR),

    /**
     * Door lock
     *
     * 'true' indicates door is locked
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_LOCK = (
        0x0B02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:DOOR),

    /**
     * Mirror Z Position
     *
     * Positive value indicates tilt upwards, negative value is downwards
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Z_POS = (
        0x0B40
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Z Move
     *
     * Positive value indicates tilt upwards, negative value is downwards
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Z_MOVE = (
        0x0B41
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Y Position
     *
     * Positive value indicate tilt right, negative value is left
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Y_POS = (
        0x0B42
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Y Move
     *
     * Positive value indicate tilt right, negative value is left
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Y_MOVE = (
        0x0B43
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),

    /**
     * Mirror Lock
     *
     * True indicates mirror positions are locked and not changeable
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_LOCK = (
        0x0B44
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Mirror Fold
     *
     * True indicates mirrors are folded
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_FOLD = (
        0x0B45
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),

    /**
     * Seat memory select
     *
     * This parameter selects the memory preset to use to select the seat
     * position. The minValue is always 0, and the maxValue determines the
     * number of seat positions available.
     *
     * For instance, if the driver's seat has 3 memory presets, the maxValue
     * will be 3. When the user wants to select a preset, the desired preset
     * number (1, 2, or 3) is set.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    SEAT_MEMORY_SELECT = (
        0x0B80
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat memory set
     *
     * This setting allows the user to save the current seat position settings
     * into the selected preset slot.  The maxValue for each seat position
     * shall match the maxValue for SEAT_MEMORY_SELECT.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    SEAT_MEMORY_SET = (
        0x0B81
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seatbelt buckled
     *
     * True indicates belt is buckled.
     *
     * Write access indicates automatic seat buckling capabilities.  There are
     * no known cars at this time, but you never know...
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_BUCKLED = (
        0x0B82
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),

    /**
     * Seatbelt height position
     *
     * Adjusts the shoulder belt anchor point.
     * Max value indicates highest position
     * Min value indicates lowest position
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_HEIGHT_POS = (
        0x0B83
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seatbelt height move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_HEIGHT_MOVE = (
        0x0B84
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat fore/aft position
     *
     * Sets the seat position forward (closer to steering wheel) and backwards.
     * Max value indicates closest to wheel, min value indicates most rearward
     * position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_FORE_AFT_POS = (
        0x0B85
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat fore/aft move
     *
     * Moves the seat position forward and aft.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_FORE_AFT_MOVE = (
        0x0B86
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 1 position
     *
     * Backrest angle 1 is the actuator closest to the bottom of the seat.
     * Max value indicates angling forward towards the steering wheel.
     * Min value indicates full recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_1_POS = (
        0x0B87
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 1 move
     *
     * Moves the backrest forward or recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_1_MOVE = (
        0x0B88
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 2 position
     *
     * Backrest angle 2 is the next actuator up from the bottom of the seat.
     * Max value indicates angling forward towards the steering wheel.
     * Min value indicates full recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_2_POS = (
        0x0B89
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat backrest angle 2 move
     *
     * Moves the backrest forward or recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_2_MOVE = (
        0x0B8A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat height position
     *
     * Sets the seat height.
     * Max value indicates highest position.
     * Min value indicates lowest position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEIGHT_POS = (
        0x0B8B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat height move
     *
     * Moves the seat height.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEIGHT_MOVE = (
        0x0B8C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat depth position
     *
     * Sets the seat depth, distance from back rest to front edge of seat.
     * Max value indicates longest depth position.
     * Min value indicates shortest position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_DEPTH_POS = (
        0x0B8D
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat depth move
     *
     * Adjusts the seat depth.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_DEPTH_MOVE = (
        0x0B8E
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat tilt position
     *
     * Sets the seat tilt.
     * Max value indicates front edge of seat higher than back edge.
     * Min value indicates front edge of seat lower than back edge.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_TILT_POS = (
        0x0B8F
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Seat tilt move
     *
     * Tilts the seat.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_TILT_MOVE = (
        0x0B90
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumber fore/aft position
     *
     * Pushes the lumbar support forward and backwards
     * Max value indicates most forward position.
     * Min value indicates most rearward position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_FORE_AFT_POS = (
        0x0B91
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumbar fore/aft move
     *
     * Adjusts the lumbar support.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_FORE_AFT_MOVE = (
        0x0B92
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumbar side support position
     *
     * Sets the amount of lateral lumbar support.
     * Max value indicates widest lumbar setting (i.e. least support)
     * Min value indicates thinnest lumbar setting.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_SIDE_SUPPORT_POS = (
        0x0B93
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Lumbar side support move
     *
     * Adjusts the amount of lateral lumbar support.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_SIDE_SUPPORT_MOVE = (
        0x0B94
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest height position
     *
     * Sets the headrest height.
     * Max value indicates tallest setting.
     * Min value indicates shortest setting.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_HEIGHT_POS = (
        0x0B95
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),

    /**
     * Headrest height move
     *
     * Moves the headrest up and down.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_HEIGHT_MOVE = (
        0x0B96
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest angle position
     *
     * Sets the angle of the headrest.
     * Max value indicates most upright angle.
     * Min value indicates shallowest headrest angle.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_ANGLE_POS = (
        0x0B97
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest angle move
     *
     * Adjusts the angle of the headrest
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_ANGLE_MOVE = (
        0x0B98
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest fore/aft position
     *
     * Adjusts the headrest forwards and backwards.
     * Max value indicates position closest to front of car.
     * Min value indicates position closest to rear of car.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_FORE_AFT_POS = (
        0x0B99
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Headrest fore/aft move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_FORE_AFT_MOVE = (
        0x0B9A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),

    /**
     * Window Position
     *
     * Max = window up / closed
     * Min = window down / open
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_POS = (
        0x0BC0
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:WINDOW),

    /**
     * Window Move
     *
     * Max = window up / closed
     * Min = window down / open
     * Magnitude denotes relative speed.  I.e. +2 is faster than +1 in raising
     * the window.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_MOVE = (
        0x0BC1
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:WINDOW),

    /**
     * Window Vent Position
     *
     * This feature is used to control the vent feature on a sunroof.
     *
     * Max = vent open
     * Min = vent closed
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_VENT_POS = (
        0x0BC2
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:WINDOW),

    /**
     * Window Vent Move
     *
     * This feature is used to control the vent feature on a sunroof.
     *
     * Max = vent open
     * Min = vent closed
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_VENT_MOVE = (
        0x0BC3
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:WINDOW),

    /**
     * Window Lock
     *
     * True indicates windows are locked and can't be moved.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_LOCK = (
        0x0BC4
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:WINDOW),


    /**
     * Vehicle Maps Service (VMS) message
     *
     * This property uses MIXED data to communicate vms messages.
     *
     * Its contents are to be interpreted as follows:
     * the indices defined in VmsMessageIntegerValuesIndex are to be used to
     * read from int32Values;
     * bytes is a serialized VMS message as defined in the vms protocol
     * which is opaque to the framework;
     *
     * IVehicle#get must always return StatusCode::NOT_AVAILABLE.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    VEHICLE_MAP_SERVICE = (
        0x0C00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),

    /**
     * OBD2 Live Sensor Data
     *
     * Reports a snapshot of the current (live) values of the OBD2 sensors available.
     *
     * The configArray is set as follows:
     *   configArray[0] = number of vendor-specific integer-valued sensors
     *   configArray[1] = number of vendor-specific float-valued sensors
     *
     * The values of this property are to be interpreted as in the following example.
     * Considering a configArray = {2,3}
     * int32Values must be a vector containing Obd2IntegerSensorIndex.LAST_SYSTEM_INDEX + 2
     * elements (that is, 33 elements);
     * floatValues must be a vector containing Obd2FloatSensorIndex.LAST_SYSTEM_INDEX + 3
     * elements (that is, 73 elements);
     *
     * It is possible for each frame to contain a different subset of sensor values, both system
     * provided sensors, and vendor-specific ones. In order to support that, the bytes element
     * of the property value is used as a bitmask,.
     *
     * bytes must have a sufficient number of bytes to represent the total number of possible
     * sensors (in this case, 14 bytes to represent 106 possible values); it is to be read as
     * a contiguous bitmask such that each bit indicates the presence or absence of a sensor
     * from the frame, starting with as many bits as the size of int32Values, immediately
     * followed by as many bits as the size of floatValues.
     *
     * For example, should bytes[0] = 0x4C (0b01001100) it would mean that:
     *   int32Values[0 and 1] are not valid sensor values
     *   int32Values[2 and 3] are valid sensor values
     *   int32Values[4 and 5] are not valid sensor values
     *   int32Values[6] is a valid sensor value
     *   int32Values[7] is not a valid sensor value
     * Should bytes[5] = 0x61 (0b01100001) it would mean that:
     *   int32Values[32] is a valid sensor value
     *   floatValues[0 thru 3] are not valid sensor values
     *   floatValues[4 and 5] are valid sensor values
     *   floatValues[6] is not a valid sensor value
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    OBD2_LIVE_FRAME = (
      0x0D00
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:MIXED
      | VehicleArea:GLOBAL),

    /**
     * OBD2 Freeze Frame Sensor Data
     *
     * Reports a snapshot of the value of the OBD2 sensors available at the time that a fault
     * occurred and was detected.
     *
     * A configArray must be provided with the same meaning as defined for OBD2_LIVE_FRAME.
     *
     * The values of this property are to be interpreted in a similar fashion as those for
     * OBD2_LIVE_FRAME, with the exception that the stringValue field may contain a non-empty
     * diagnostic troubleshooting code (DTC).
     *
     * A IVehicle#get request of this property must provide a value for int64Values[0].
     * This will be interpreted as the timestamp of the freeze frame to retrieve. A list of
     * timestamps can be obtained by a IVehicle#get of OBD2_FREEZE_FRAME_INFO.
     *
     * Should no freeze frame be available at the given timestamp, a response of NOT_AVAILABLE
     * must be returned by the implementation. Because vehicles may have limited storage for
     * freeze frames, it is possible for a frame request to respond with NOT_AVAILABLE even if
     * the associated timestamp has been recently obtained via OBD2_FREEZE_FRAME_INFO.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    OBD2_FREEZE_FRAME = (
      0x0D01
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:MIXED
      | VehicleArea:GLOBAL),

    /**
     * OBD2 Freeze Frame Information
     *
     * This property describes the current freeze frames stored in vehicle
     * memory and available for retrieval via OBD2_FREEZE_FRAME.
     *
     * The values are to be interpreted as follows:
     * each element of int64Values must be the timestamp at which a a fault code
     * has been detected and the corresponding freeze frame stored, and each
     * such element can be used as the key to OBD2_FREEZE_FRAME to retrieve
     * the corresponding freeze frame.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    OBD2_FREEZE_FRAME_INFO = (
      0x0D02
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:MIXED
      | VehicleArea:GLOBAL),

    /**
     * OBD2 Freeze Frame Clear
     *
     * This property allows deletion of any of the freeze frames stored in
     * vehicle memory, as described by OBD2_FREEZE_FRAME_INFO.
     *
     * The configArray is set as follows:
     *  configArray[0] = 1 if the implementation is able to clear individual freeze frames
     *                   by timestamp, 0 otherwise
     *
     * IVehicle#set of this property is to be interpreted as follows:
     *   if int64Values contains no elements, then all frames stored must be cleared;
     *   if int64Values contains one or more elements, then frames at the timestamps
     *   stored in int64Values must be cleared, and the others not cleared. Should the
     *   vehicle not support selective clearing of freeze frames, this latter mode must
     *   return NOT_AVAILABLE.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    OBD2_FREEZE_FRAME_CLEAR = (
      0x0D03
      | VehiclePropertyGroup:SYSTEM
      | VehiclePropertyType:MIXED
      | VehicleArea:GLOBAL),
};

/**
 * Used by INFO_EV_CONNECTOR_TYPE to enumerate the type of connectors
 * available to charge the vehicle.  Consistent with projection protocol.
 */
enum EvConnectorType : int32_t {
    /**
     * Default type if the vehicle does not know or report the EV connector
     * type.
     */
    EV_CONNECTOR_TYPE_UNKNOWN = 0,
    EV_CONNECTOR_TYPE_J1772 = 1,
    EV_CONNECTOR_TYPE_MENNEKES = 2,
    EV_CONNECTOR_TYPE_CHADEMO = 3,
    EV_CONNECTOR_TYPE_COMBO_1 = 4,
    EV_CONNECTOR_TYPE_COMBO_2 = 5,
    EV_CONNECTOR_TYPE_TESLA_ROADSTER = 6,
    EV_CONNECTOR_TYPE_TESLA_HPWC = 7,
    EV_CONNECTOR_TYPE_TESLA_SUPERCHARGER = 8,
    EV_CONNECTOR_TYPE_GBT = 9,

    /**
     * Connector type to use when no other types apply. Before using this
     * value, work with Google to see if the EvConnectorType enum can be
     * extended with an appropriate value.
     */
    EV_CONNECTOR_TYPE_OTHER = 101,
};

/**
 * Used by INFO_FUEL_TYPE to enumerate the type of fuels this vehicle uses.
 * Consistent with projection protocol.
 */
enum FuelType : int32_t {
    /**
     * Fuel type to use if the HU does not know on which types of fuel the vehicle
     * runs. The use of this value is generally discouraged outside of aftermarket units.
     */
    FUEL_TYPE_UNKNOWN = 0,
    /** Unleaded gasoline */
    FUEL_TYPE_UNLEADED = 1,
    /** Leaded gasoline */
    FUEL_TYPE_LEADED = 2,
    /** Diesel #1 */
    FUEL_TYPE_DIESEL_1 = 3,
    /** Diesel #2 */
    FUEL_TYPE_DIESEL_2 = 4,
    /** Biodiesel */
    FUEL_TYPE_BIODIESEL = 5,
    /** 85% ethanol/gasoline blend */
    FUEL_TYPE_E85 = 6,
    /** Liquified petroleum gas */
    FUEL_TYPE_LPG = 7,
    /** Compressed natural gas */
    FUEL_TYPE_CNG = 8,
    /** Liquified natural gas */
    FUEL_TYPE_LNG = 9,
    /** Electric */
    FUEL_TYPE_ELECTRIC = 10,
    /** Hydrogen fuel cell */
    FUEL_TYPE_HYDROGEN = 11,
    /**
     * Fuel type to use when no other types apply. Before using this value, work with
     * Google to see if the FuelType enum can be extended with an appropriate value.
     */
    FUEL_TYPE_OTHER = 12,
};

/**
 * Bit flags for fan direction
 */
enum VehicleHvacFanDirection : int32_t {
    FACE = 0x1,
    FLOOR = 0x2,
    DEFROST = 0x4,
};

enum VehicleOilLevel : int32_t {
    /**
     * Oil level values
     */
    CRITICALLY_LOW = 0,
    LOW = 1,
    NORMAL = 2,
    HIGH = 3,
    ERROR = 4,
};

/**
 * Constants relevant to radio.
 */
enum VehicleRadioConstants : int32_t {
    /** Minimum value for the radio preset */
    VEHICLE_RADIO_PRESET_MIN_VALUE = 1,
};

enum VehicleApPowerStateConfigFlag : int32_t /* NOTE: type is guessed */ {
    /**
     * AP can enter deep sleep state. If not set, AP will always shutdown from
     * VehicleApPowerState#SHUTDOWN_PREPARE power state.
     */
    ENABLE_DEEP_SLEEP_FLAG = 0x1,

    /**
     * The power controller can power on AP from off state after timeout
     * specified in VehicleApPowerSet VEHICLE_AP_POWER_SET_SHUTDOWN_READY message.
     */
    CONFIG_SUPPORT_TIMER_POWER_ON_FLAG = 0x2,
};

enum VehicleApPowerState : int32_t /* NOTE: type is guessed */ {
    /** vehicle HAL will never publish this state to AP */
    OFF = 0,

    /** vehicle HAL will never publish this state to AP */
    DEEP_SLEEP = 1,

    /** AP is on but display must be off. */
    ON_DISP_OFF = 2,

    /** AP is on with display on. This state allows full user interaction. */
    ON_FULL = 3,

    /**
     * The power controller has requested AP to shutdown. AP can either enter
     * sleep state or start full shutdown. AP can also request postponing
     * shutdown by sending VehicleApPowerSetState#SHUTDOWN_POSTPONE message. The
     * power controller must change power state to this state to shutdown
     * system.
     *
     * int32Values[1] : one of enum_vehicle_ap_power_state_shutdown_param_type
     */
    SHUTDOWN_PREPARE = 4,
};

enum VehicleApPowerStateShutdownParam : int32_t {
    /** AP must shutdown immediately. Postponing is not allowed. */
    SHUTDOWN_IMMEDIATELY = 1,

    /** AP can enter deep sleep instead of shutting down completely. */
    CAN_SLEEP = 2,

    /** AP can only shutdown with postponing allowed. */
    SHUTDOWN_ONLY = 3,
};

enum VehicleApPowerSetState : int32_t /* NOTE: type is guessed */ {
    /**
     * AP has finished boot up, and can start shutdown if requested by power
     * controller.
     */
    BOOT_COMPLETE = 0x1,

    /**
     * AP is entering deep sleep state. How this state is implemented may vary
     * depending on each H/W, but AP's power must be kept in this state.
     */
    DEEP_SLEEP_ENTRY = 0x2,

    /**
     * AP is exiting from deep sleep state, and is in
     * VehicleApPowerState#SHUTDOWN_PREPARE state.
     * The power controller may change state to other ON states based on the
     * current state.
     */
    DEEP_SLEEP_EXIT = 0x3,

    /**
     * int32Values[1]: Time to postpone shutdown in ms. Maximum value can be
     *                 5000 ms.
     *                 If AP needs more time, it will send another POSTPONE
     *                 message before the previous one expires.
     */
    SHUTDOWN_POSTPONE = 0x4,

    /**
     * AP is starting shutting down. When system completes shutdown, everything
     * will stop in AP as kernel will stop all other contexts. It is
     * responsibility of vehicle HAL or lower level to synchronize that state
     * with external power controller. As an example, some kind of ping
     * with timeout in power controller can be a solution.
     *
     * int32Values[1]: Time to turn on AP in secs. Power controller may turn on
     *                 AP after specified time so that AP can run tasks like
     *                 update. If it is set to 0, there is no wake up, and power
     *                 controller may not necessarily support wake-up. If power
     *                 controller turns on AP due to timer, it must start with
     *                 VehicleApPowerState#ON_DISP_OFF state, and after
     *                 receiving VehicleApPowerSetState#BOOT_COMPLETE, it shall
     *                 do state transition to
     *                 VehicleApPowerState#SHUTDOWN_PREPARE.
     */
    SHUTDOWN_START = 0x5,

    /**
     * User has requested to turn off headunit's display, which is detected in
     * android side.
     * The power controller may change the power state to
     * VehicleApPowerState#ON_DISP_OFF.
     */
    DISPLAY_OFF = 0x6,

    /**
     * User has requested to turn on headunit's display, most probably from power
     * key input which is attached to headunit. The power controller may change
     * the power state to VehicleApPowerState#ON_FULL.
     */
    DISPLAY_ON = 0x7,
};

/**
 * Index in int32Values for VehicleProperty#AP_POWER_STATE property.
 */
enum VehicleApPowerStateIndex : int32_t {
    STATE = 0,
    ADDITIONAL = 1,
};

/**
 * Enum to represent bootup reason.
 */
enum VehicleApPowerBootupReason : int32_t {
    /**
     * Power on due to user's pressing of power key or rotating of ignition
     * switch.
     */
    USER_POWER_ON = 0,

    /**
     * Automatic power on triggered by door unlock or any other kind of automatic
     * user detection.
     */
    USER_UNLOCK = 1,

    /**
     * Automatic power on triggered by timer. This only happens when AP has asked
     * wake-up after
     * certain time through time specified in
     * VehicleApPowerSetState#SHUTDOWN_START.
     */
    TIMER = 2,
};

enum VehicleHwKeyInputAction : int32_t {
    /** Key down */
    ACTION_DOWN = 0,

    /** Key up */
    ACTION_UP = 1,
};

enum VehicleDisplay : int32_t {
    /** center console */
    MAIN = 0,

    INSTRUMENT_CLUSTER = 1,
};

/**
 * Units used for int or float type with no attached enum types.
 */
enum VehicleUnit : int32_t {
    SHOULD_NOT_USE = 0x000,

    METER_PER_SEC  = 0x01,
    RPM            = 0x02,
    HERTZ          = 0x03,
    PERCENTILE     = 0x10,
    MILLIMETER     = 0x20,
    METER          = 0x21,
    KILOMETER      = 0x23,
    CELSIUS        = 0x30,
    FAHRENHEIT     = 0x31,
    KELVIN         = 0x32,
    MILLILITER     = 0x40,
    NANO_SECS      = 0x50,
    SECS           = 0x53,
    YEAR           = 0x59,

    // Electrical Units
    WATT_HOUR      = 0x60,
    MILLIAMPERE    = 0x61,
    MILLIVOLT      = 0x62,
    MILLIWATTS     = 0x63,
};

  /**
   * This describes how value of property can change.
   */
enum VehiclePropertyChangeMode : int32_t {
  /**
   * Property of this type must never be changed. Subscription is not supported
   * for these properties.
   */
  STATIC = 0x00,

  /**
   * Property of this type must be reported when there is a change.
   * IVehicle#get call must return the current value.
   * Set operation for this property is assumed to be asynchronous. When the
   * property is read (using IVehicle#get) after IVehicle#set, it may still
   * return old value until underlying H/W backing this property has actually
   * changed the state. Once state is changed, the property must dispatch
   * changed value as event.
   */
  ON_CHANGE = 0x01,

  /**
   * Property of this type change continuously and requires fixed rate of
   * sampling to retrieve the data.
   */
  CONTINUOUS = 0x02,

  /**
   * Property of this type may be polled to get the current value.
   */
  POLL = 0x03,

  /**
   * This is for property where change event must be sent only when the
   * value is set from external component. Normal value change must not trigger
   * event. For example, clock property can send change event only when it is
   * set, outside android, for case like user setting time or time getting
   * update. There is no need to send it per every value change.
   */
  ON_SET = 0x04,
};

/**
 * Property config defines the capabilities of it. User of the API
 * must first get the property config to understand the output from get()
 * commands and also to ensure that set() or events commands are in sync with
 * the expected output.
 */
enum VehiclePropertyAccess : int32_t {
    NONE = 0x00,

    READ = 0x01,
    WRITE = 0x02,
    READ_WRITE = 0x03,
};

/**
 * Property status is a dynamic value that may change based on the vehicle state.
 */
enum VehiclePropertyStatus : int32_t {
    /** Property is available and behaving normally */
    AVAILABLE   = 0x00,
    /**
     * Property is not available, for read and/or write.  This is a transient state, as the
     *  property is expected to be available at a later time.
     */
    UNAVAILABLE = 0x01,
    /** There is an error with this property. */
    ERROR       = 0x02,
};

/**
 * Car states.
 *
 * The driving states determine what features of the UI will be accessible.
 */
enum VehicleDrivingStatus : int32_t {
    UNRESTRICTED = 0x00,
    NO_VIDEO = 0x01,
    NO_KEYBOARD_INPUT = 0x02,
    NO_VOICE_INPUT = 0x04,
    NO_CONFIG = 0x08,
    LIMIT_MESSAGE_LEN = 0x10,
};

/**
 * Various gears which can be selected by user and chosen in system.
 */
enum VehicleGear: int32_t {
    GEAR_NEUTRAL = 0x0001,
    GEAR_REVERSE = 0x0002,
    GEAR_PARK = 0x0004,
    GEAR_DRIVE = 0x0008,
    GEAR_LOW = 0x0010,
    GEAR_1 = 0x0010,
    GEAR_2 = 0x0020,
    GEAR_3 = 0x0040,
    GEAR_4 = 0x0080,
    GEAR_5 = 0x0100,
    GEAR_6 = 0x0200,
    GEAR_7 = 0x0400,
    GEAR_8 = 0x0800,
    GEAR_9 = 0x1000,
};

/**
 * Various zones in the car.
 *
 * Zones are used for Air Conditioning purposes and divide the car into physical
 * area zones.
 */
enum VehicleAreaZone : int32_t {
  ROW_1_LEFT = 0x00000001,
  ROW_1_CENTER = 0x00000002,
  ROW_1_RIGHT = 0x00000004,
  ROW_2_LEFT = 0x00000010,
  ROW_2_CENTER = 0x00000020,
  ROW_2_RIGHT = 0x00000040,
  ROW_3_LEFT = 0x00000100,
  ROW_3_CENTER = 0x00000200,
  ROW_3_RIGHT = 0x00000400,
  ROW_4_LEFT = 0x00001000,
  ROW_4_CENTER = 0x00002000,
  ROW_4_RIGHT = 0x00004000,
};

/**
 * Various Seats in the car.
 */
enum VehicleAreaSeat : int32_t {
    ROW_1_LEFT   = 0x0001,
    ROW_1_CENTER = 0x0002,
    ROW_1_RIGHT  = 0x0004,
    ROW_2_LEFT   = 0x0010,
    ROW_2_CENTER = 0x0020,
    ROW_2_RIGHT  = 0x0040,
    ROW_3_LEFT   = 0x0100,
    ROW_3_CENTER = 0x0200,
    ROW_3_RIGHT  = 0x0400
};

/**
 * Various windshields/windows in the car.
 */
enum VehicleAreaWindow : int32_t {
    FRONT_WINDSHIELD = 0x0001,
    REAR_WINDSHIELD = 0x0002,
    ROOF_TOP = 0x0004,
    ROW_1_LEFT = 0x0010,
    ROW_1_RIGHT = 0x0020,
    ROW_2_LEFT = 0x0100,
    ROW_2_RIGHT = 0x0200,
    ROW_3_LEFT = 0x1000,
    ROW_3_RIGHT = 0x2000,
};

enum VehicleAreaDoor : int32_t {
    ROW_1_LEFT = 0x00000001,
    ROW_1_RIGHT = 0x00000004,
    ROW_2_LEFT = 0x00000010,
    ROW_2_RIGHT = 0x00000040,
    ROW_3_LEFT = 0x00000100,
    ROW_3_RIGHT = 0x00000400,
    HOOD = 0x10000000,
    REAR = 0x20000000,
};

enum VehicleAreaMirror : int32_t {
    DRIVER_LEFT = 0x00000001,
    DRIVER_RIGHT = 0x00000002,
    DRIVER_CENTER = 0x00000004,
};

enum VehicleTurnSignal : int32_t {
    NONE = 0x00,
    RIGHT = 0x01,
    LEFT = 0x02,
    EMERGENCY = 0x04,
};

struct VehicleAreaConfig {
    /**
     * Area id is ignored for VehiclePropertyGroup:GLOBAL properties.
     */
    int32_t areaId;

    int32_t minInt32Value;
    int32_t maxInt32Value;

    int64_t minInt64Value;
    int64_t maxInt64Value;

    float minFloatValue;
    float maxFloatValue;
};

struct VehiclePropConfig {
    /** Property identifier */
    int32_t prop;

    /**
     * Defines if the property is read or write or both.
     */
    VehiclePropertyAccess access;

    /**
     * Defines the change mode of the property.
     */
    VehiclePropertyChangeMode changeMode;

    /**
     * Contains per-area configuration.
     */
    vec<VehicleAreaConfig> areaConfigs;

    /**
     * Configuration flags for this property.
     *
     * For example, it may store the number of presets that are stored by the
     * radio module.
     */
    int32_t configFlags;

    /** Contains additional configuration parameters */
    vec<int32_t> configArray;

    /**
     * Some properties may require additional information passed over this
     * string. Most properties do not need to set this.
     */
    string configString;

    /**
     * Min sample rate in Hz.
     * Must be defined for VehiclePropertyChangeMode::CONTINUOUS
     */
    float minSampleRate;

    /**
     * Must be defined for VehiclePropertyChangeMode::CONTINUOUS
     * Max sample rate in Hz.
     */
    float maxSampleRate;
};

/**
 * Encapsulates the property name and the associated value. It
 * is used across various API calls to set values, get values or to register for
 * events.
 */
struct VehiclePropValue {
    /** Property identifier */
    int32_t prop;

    /** Time is elapsed nanoseconds since boot */
    int64_t timestamp;

    /**
     * Area type(s) for non-global property it must be one of the value from
     * VehicleArea* enums or 0 for global properties.
     */
    int32_t areaId;

    /** Status of the property */
    VehiclePropertyStatus status;

    /**
     * Contains value for a single property. Depending on property data type of
     * this property (VehiclePropetyType) one field of this structure must be filled in.
     */
    struct RawValue {
        /**
         * This is used for properties of types VehiclePropertyType#INT
         * and VehiclePropertyType#INT_VEC
         */
        vec<int32_t> int32Values;

        /**
         * This is used for properties of types VehiclePropertyType#FLOAT
         * and VehiclePropertyType#FLOAT_VEC
         */
        vec<float> floatValues;

        /** This is used for properties of type VehiclePropertyType#INT64 */
        vec<int64_t> int64Values;

        /** This is used for properties of type VehiclePropertyType#BYTES */
        vec<uint8_t> bytes;

        /** This is used for properties of type VehiclePropertyType#STRING */
        string stringValue;
    };

    RawValue value;
};

enum VehicleIgnitionState : int32_t {
    UNDEFINED = 0,

    /** Steering wheel is locked */
    LOCK = 1,

     /**
      * Steering wheel is not locked, engine and all accessories are OFF. If
      * car can be in LOCK and OFF state at the same time than HAL must report
      * LOCK state.
      */
    OFF,

    /**
     * Typically in this state accessories become available (e.g. radio).
     * Instrument cluster and engine are turned off
     */
    ACC,

    /**
     * Ignition is in state ON. Accessories and instrument cluster available,
     * engine might be running or ready to be started.
     */
    ON,

    /** Typically in this state engine is starting (cranking). */
    START
};


/**
 * Represent the operation where the current error has happened.
 */
enum VehiclePropertyOperation : int32_t {
    /**
     * Generic error to this property which is not tied to any operation.
     */
    GENERIC = 0,

    /**
     * Error happened while handling property set.
     */
    SET = 1,

    /**
     * Error happened while handling property get.
     */
    GET = 2,

    /**
     * Error happened while handling property subscription.
     */
    SUBSCRIBE = 3,
};


enum SubscribeFlags : int32_t {
    UNDEFINED = 0x0,

    /**
     * Subscribe to event that was originated in vehicle HAL
     * (most likely this event came from the vehicle itself).
     */
    HAL_EVENT = 0x1,

    /**
     * Use this flag to subscribe on events when IVehicle#set(...) was called by
     * vehicle HAL's client (e.g. Car Service).
     */
    SET_CALL = 0x2,

    DEFAULT = HAL_EVENT,
};

/**
 * Encapsulates information about subscription to vehicle property events.
 */
struct SubscribeOptions {
    /** Property to subscribe */
    int32_t propId;

    /**
     * Sample rate in Hz.
     *
     * Must be provided for properties with
     * VehiclePropertyChangeMode::CONTINUOUS. The value must be within
     * VehiclePropConfig#minSamplingRate .. VehiclePropConfig#maxSamplingRate
     * for a given property.
     * This value indicates how many updates per second client wants to receive.
     */
    float sampleRate;

    /** Flags that indicate what kind of events listen to. */
    SubscribeFlags flags;
};

/** Error codes used in vehicle HAL interface. */
enum StatusCode : int32_t {
    OK = 0,

    /** Try again. */
    TRY_AGAIN = 1,

    /** Invalid argument provided. */
    INVALID_ARG = 2,

    /**
     * This code must be returned when device that associated with the vehicle
     * property is not available. For example, when client tries to set HVAC
     * temperature when the whole HVAC unit is turned OFF.
     */
    NOT_AVAILABLE = 3,

    /** Access denied */
    ACCESS_DENIED = 4,

    /** Something unexpected has happened in Vehicle HAL */
    INTERNAL_ERROR = 5,
};

enum Wheel : int32_t {
    UNKNOWN = 0x0,

    LEFT_FRONT = 0x1,
    RIGHT_FRONT = 0x2,
    LEFT_REAR = 0x4,
    RIGHT_REAR = 0x8,
};

/**
 * The status of the vehicle's fuel system.
 * These values come from the SAE J1979 standard.
 */
enum Obd2FuelSystemStatus : int32_t {
    OPEN_INSUFFICIENT_ENGINE_TEMPERATURE = 1,
    CLOSED_LOOP = 2,
    OPEN_ENGINE_LOAD_OR_DECELERATION = 4,
    OPEN_SYSTEM_FAILURE = 8,
    CLOSED_LOOP_BUT_FEEDBACK_FAULT = 16,
};

/** Defines which ignition monitors are available to be read. */
enum Obd2IgnitionMonitorKind : int32_t {
    SPARK = 0,
    COMPRESSION = 1,
};

/**
 * Ignition monitors common to both SPARK and COMPRESSION.
 * These values come from the SAE J1979 standard.
 */
enum Obd2CommonIgnitionMonitors : int32_t {
    COMPONENTS_AVAILABLE = 0x1 << 0,
    COMPONENTS_INCOMPLETE = 0x1 << 1,

    FUEL_SYSTEM_AVAILABLE = 0x1 << 2,
    FUEL_SYSTEM_INCOMPLETE = 0x1 << 3,

    MISFIRE_AVAILABLE = 0x1 << 4,
    MISFIRE_INCOMPLETE = 0x1 << 5,
};

/**
 * Ignition monitors available for SPARK vehicles.
 * These values come from the SAE J1979 standard.
 */
enum Obd2SparkIgnitionMonitors : Obd2CommonIgnitionMonitors {
    EGR_AVAILABLE = 0x1 << 6,
    EGR_INCOMPLETE = 0x1 << 7,

    OXYGEN_SENSOR_HEATER_AVAILABLE = 0x1 << 8,
    OXYGEN_SENSOR_HEATER_INCOMPLETE = 0x1 << 9,

    OXYGEN_SENSOR_AVAILABLE = 0x1 << 10,
    OXYGEN_SENSOR_INCOMPLETE = 0x1 << 11,

    AC_REFRIGERANT_AVAILABLE = 0x1 << 12,
    AC_REFRIGERANT_INCOMPLETE = 0x1 << 13,

    SECONDARY_AIR_SYSTEM_AVAILABLE = 0x1 << 14,
    SECONDARY_AIR_SYSTEM_INCOMPLETE = 0x1 << 15,

    EVAPORATIVE_SYSTEM_AVAILABLE = 0x1 << 16,
    EVAPORATIVE_SYSTEM_INCOMPLETE = 0x1 << 17,

    HEATED_CATALYST_AVAILABLE = 0x1 << 18,
    HEATED_CATALYST_INCOMPLETE = 0x1 << 19,

    CATALYST_AVAILABLE = 0x1 << 20,
    CATALYST_INCOMPLETE = 0x1 << 21,
};

/**
 * Ignition monitors only available for COMPRESSION vehicles.
 * These values come from the SAE J1979 standard.
 */
enum Obd2CompressionIgnitionMonitors : Obd2CommonIgnitionMonitors {
    EGR_OR_VVT_AVAILABLE = 0x1 << 6,
    EGR_OR_VVT_INCOMPLETE = 0x1 << 7,

    PM_FILTER_AVAILABLE = 0x1 << 8,
    PM_FILTER_INCOMPLETE = 0x1 << 9,

    EXHAUST_GAS_SENSOR_AVAILABLE = 0x1 << 10,
    EXHAUST_GAS_SENSOR_INCOMPLETE = 0x1 << 11,

    BOOST_PRESSURE_AVAILABLE = 0x1 << 12,
    BOOST_PRESSURE_INCOMPLETE = 0x1 << 13,

    NOx_SCR_AVAILABLE = 0x1 << 14,
    NOx_SCR_INCOMPLETE = 0x1 << 15,

    NMHC_CATALYST_AVAILABLE = 0x1 << 16,
    NMHC_CATALYST_INCOMPLETE = 0x1 << 17,
};

/**
 * The status of the vehicle's secondary air system.
 * These values come from the SAE J1979 standard.
 */
enum Obd2SecondaryAirStatus : int32_t {
    UPSTREAM = 1,
    DOWNSTREAM_OF_CATALYCIC_CONVERTER = 2,
    FROM_OUTSIDE_OR_OFF = 4,
    PUMP_ON_FOR_DIAGNOSTICS = 8,
};

/**
 * The fuel type(s) supported by a vehicle.
 * These values come from the SAE J1979 standard.
 */
enum Obd2FuelType : int32_t {
    NOT_AVAILABLE = 0,
    GASOLINE = 1,
    METHANOL = 2,
    ETHANOL = 3,
    DIESEL = 4,
    LPG = 5,
    CNG = 6,
    PROPANE = 7,
    ELECTRIC = 8,
    BIFUEL_RUNNING_GASOLINE = 9,
    BIFUEL_RUNNING_METHANOL = 10,
    BIFUEL_RUNNING_ETHANOL = 11,
    BIFUEL_RUNNING_LPG = 12,
    BIFUEL_RUNNING_CNG = 13,
    BIFUEL_RUNNING_PROPANE = 14,
    BIFUEL_RUNNING_ELECTRIC = 15,
    BIFUEL_RUNNING_ELECTRIC_AND_COMBUSTION = 16,
    HYBRID_GASOLINE = 17,
    HYBRID_ETHANOL = 18,
    HYBRID_DIESEL = 19,
    HYBRID_ELECTRIC = 20,
    HYBRID_RUNNING_ELECTRIC_AND_COMBUSTION = 21,
    HYBRID_REGENERATIVE = 22,
    BIFUEL_RUNNING_DIESEL = 23,
};

/**
 * This enum provides the canonical mapping for sensor properties that have an integer value.
 * The ordering of the values is taken from the OBD2 specification.
 * Some of the properties are represented as an integer mapping to another enum. In those cases
 * expect a comment by the property definition describing the enum to look at for the mapping.
 * Any value greater than the last reserved index is available to vendors to map their extensions.
 * While these values do not directly map to SAE J1979 PIDs, an equivalence is listed next
 * to each one to aid implementors.
 */
enum DiagnosticIntegerSensorIndex : int32_t {
    /** refer to FuelSystemStatus for a description of this value. */
    FUEL_SYSTEM_STATUS = 0, /* PID 0x03 */
    MALFUNCTION_INDICATOR_LIGHT_ON = 1, /* PID 0x01 */

    /** refer to IgnitionMonitorKind for a description of this value. */
    IGNITION_MONITORS_SUPPORTED = 2, /* PID 0x01 */

    /**
     * The value of this sensor is a bitmask that specifies whether ignition-specific
     * tests are available and whether they are complete. The semantics of the individual
     * bits in this value are given by, respectively, SparkIgnitionMonitors and
     * CompressionIgnitionMonitors depending on the value of IGNITION_MONITORS_SUPPORTED.
     */
    IGNITION_SPECIFIC_MONITORS = 3, /* PID 0x01 */
    INTAKE_AIR_TEMPERATURE = 4, /* PID 0x0F */

    /** refer to SecondaryAirStatus for a description of this value. */
    COMMANDED_SECONDARY_AIR_STATUS = 5, /* PID 0x12 */
    NUM_OXYGEN_SENSORS_PRESENT = 6, /* PID 0x13 */
    RUNTIME_SINCE_ENGINE_START = 7, /* PID 0x1F */
    DISTANCE_TRAVELED_WITH_MALFUNCTION_INDICATOR_LIGHT_ON = 8, /* PID 0x21 */
    WARMUPS_SINCE_CODES_CLEARED = 9, /* PID 0x30 */
    DISTANCE_TRAVELED_SINCE_CODES_CLEARED = 10, /* PID 0x31 */
    ABSOLUTE_BAROMETRIC_PRESSURE = 11, /* PID 0x33 */
    CONTROL_MODULE_VOLTAGE = 12, /* PID 0x42 */
    AMBIENT_AIR_TEMPERATURE = 13, /* PID 0x46 */
    TIME_WITH_MALFUNCTION_LIGHT_ON = 14, /* PID 0x4D */
    TIME_SINCE_TROUBLE_CODES_CLEARED = 15, /* PID 0x4E */
    MAX_FUEL_AIR_EQUIVALENCE_RATIO = 16, /* PID 0x4F */
    MAX_OXYGEN_SENSOR_VOLTAGE = 17, /* PID 0x4F */
    MAX_OXYGEN_SENSOR_CURRENT = 18, /* PID 0x4F */
    MAX_INTAKE_MANIFOLD_ABSOLUTE_PRESSURE = 19, /* PID 0x4F */
    MAX_AIR_FLOW_RATE_FROM_MASS_AIR_FLOW_SENSOR = 20, /* PID 0x50 */

    /** refer to FuelType for a description of this value. */
    FUEL_TYPE = 21, /* PID 0x51 */
    FUEL_RAIL_ABSOLUTE_PRESSURE = 22, /* PID 0x59 */
    ENGINE_OIL_TEMPERATURE = 23, /* PID 0x5C */
    DRIVER_DEMAND_PERCENT_TORQUE = 24, /* PID 0x61 */
    ENGINE_ACTUAL_PERCENT_TORQUE = 25, /* PID 0x62 */
    ENGINE_REFERENCE_PERCENT_TORQUE = 26, /* PID 0x63 */
    ENGINE_PERCENT_TORQUE_DATA_IDLE = 27, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT1 = 28, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT2 = 29, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT3 = 30, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT4 = 31, /* PID 0x64 */
    LAST_SYSTEM_INDEX = ENGINE_PERCENT_TORQUE_DATA_POINT4,
};

/**
 * This enum provides the canonical mapping for sensor properties that have a floating-point value.
 * The ordering of the values is taken from the OBD2 specification.
 * Any value greater than the last reserved index is available to vendors to map their extensions.
 * While these values do not directly map to SAE J1979 PIDs, an equivalence is listed next
 * to each one to aid implementors.
 */
enum DiagnosticFloatSensorIndex : int32_t {
    CALCULATED_ENGINE_LOAD = 0, /* PID 0x04 */
    ENGINE_COOLANT_TEMPERATURE = 1, /* PID 0x05 */
    SHORT_TERM_FUEL_TRIM_BANK1 = 2, /* PID 0x06 */
    LONG_TERM_FUEL_TRIM_BANK1 = 3, /* PID 0x07 */
    SHORT_TERM_FUEL_TRIM_BANK2 = 4, /* PID 0x08 */
    LONG_TERM_FUEL_TRIM_BANK2 = 5, /* PID 0x09 */
    FUEL_PRESSURE = 6, /* PID 0x0A */
    INTAKE_MANIFOLD_ABSOLUTE_PRESSURE = 7, /* PID 0x0B */
    ENGINE_RPM = 8, /* PID 0x0C */
    VEHICLE_SPEED = 9, /* PID 0x0D */
    TIMING_ADVANCE = 10, /* PID 0x0E */
    MAF_AIR_FLOW_RATE = 11, /* PID 0x10 */
    THROTTLE_POSITION = 12, /* PID 0x11 */
    OXYGEN_SENSOR1_VOLTAGE = 13, /* PID 0x14 */
    OXYGEN_SENSOR1_SHORT_TERM_FUEL_TRIM = 14, /* PID 0x14 */
    OXYGEN_SENSOR1_FUEL_AIR_EQUIVALENCE_RATIO = 15, /* PID 0x24 */
    OXYGEN_SENSOR2_VOLTAGE = 16, /* PID 0x15 */
    OXYGEN_SENSOR2_SHORT_TERM_FUEL_TRIM = 17, /* PID 0x15 */
    OXYGEN_SENSOR2_FUEL_AIR_EQUIVALENCE_RATIO = 18, /* PID 0x25 */
    OXYGEN_SENSOR3_VOLTAGE = 19, /* PID 0x16 */
    OXYGEN_SENSOR3_SHORT_TERM_FUEL_TRIM = 20, /* PID 0x16 */
    OXYGEN_SENSOR3_FUEL_AIR_EQUIVALENCE_RATIO = 21, /* PID 0x26 */
    OXYGEN_SENSOR4_VOLTAGE = 22, /* PID 0x17 */
    OXYGEN_SENSOR4_SHORT_TERM_FUEL_TRIM = 23, /* PID 0x17 */
    OXYGEN_SENSOR4_FUEL_AIR_EQUIVALENCE_RATIO = 24, /* PID 0x27 */
    OXYGEN_SENSOR5_VOLTAGE = 25, /* PID 0x18 */
    OXYGEN_SENSOR5_SHORT_TERM_FUEL_TRIM = 26, /* PID 0x18 */
    OXYGEN_SENSOR5_FUEL_AIR_EQUIVALENCE_RATIO = 27, /* PID 0x28 */
    OXYGEN_SENSOR6_VOLTAGE = 28, /* PID 0x19 */
    OXYGEN_SENSOR6_SHORT_TERM_FUEL_TRIM = 29, /* PID 0x19 */
    OXYGEN_SENSOR6_FUEL_AIR_EQUIVALENCE_RATIO = 30, /* PID 0x29 */
    OXYGEN_SENSOR7_VOLTAGE = 31, /* PID 0x1A */
    OXYGEN_SENSOR7_SHORT_TERM_FUEL_TRIM = 32, /* PID 0x1A */
    OXYGEN_SENSOR7_FUEL_AIR_EQUIVALENCE_RATIO = 33, /* PID 0x2A */
    OXYGEN_SENSOR8_VOLTAGE = 34, /* PID 0x1B */
    OXYGEN_SENSOR8_SHORT_TERM_FUEL_TRIM = 35, /* PID 0x1B */
    OXYGEN_SENSOR8_FUEL_AIR_EQUIVALENCE_RATIO = 36, /* PID 0x2B */
    FUEL_RAIL_PRESSURE = 37, /* PID 0x22 */
    FUEL_RAIL_GAUGE_PRESSURE = 38, /* PID 0x23 */
    COMMANDED_EXHAUST_GAS_RECIRCULATION = 39, /* PID 0x2C */
    EXHAUST_GAS_RECIRCULATION_ERROR = 40, /* PID 0x2D */
    COMMANDED_EVAPORATIVE_PURGE = 41, /* PID 0x2E */
    FUEL_TANK_LEVEL_INPUT = 42, /* PID 0x2F */
    EVAPORATION_SYSTEM_VAPOR_PRESSURE = 43, /* PID 0x32 */
    CATALYST_TEMPERATURE_BANK1_SENSOR1 = 44, /* PID 0x3C */
    CATALYST_TEMPERATURE_BANK2_SENSOR1 = 45, /* PID 0x3D */
    CATALYST_TEMPERATURE_BANK1_SENSOR2 = 46, /* PID 0x3E */
    CATALYST_TEMPERATURE_BANK2_SENSOR2 = 47, /* PID 0x3F */
    ABSOLUTE_LOAD_VALUE = 48, /* PID 0x43 */
    FUEL_AIR_COMMANDED_EQUIVALENCE_RATIO = 49, /* PID 0x44 */
    RELATIVE_THROTTLE_POSITION = 50, /* PID 0x45 */
    ABSOLUTE_THROTTLE_POSITION_B = 51, /* PID 0x47 */
    ABSOLUTE_THROTTLE_POSITION_C = 52, /* PID 0x48 */
    ACCELERATOR_PEDAL_POSITION_D = 53, /* PID 0x49 */
    ACCELERATOR_PEDAL_POSITION_E = 54, /* PID 0x4A */
    ACCELERATOR_PEDAL_POSITION_F = 55, /* PID 0x4B */
    COMMANDED_THROTTLE_ACTUATOR = 56, /* PID 0x4C */
    ETHANOL_FUEL_PERCENTAGE = 57,/* PID 0x52 */
    ABSOLUTE_EVAPORATION_SYSTEM_VAPOR_PRESSURE = 58, /* PID 0x53 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK1 = 59, /* PID 0x55 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK2 = 60, /* PID 0x57 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK3 = 61,/* PID 0x55 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK4 = 62, /* PID 0x57 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK1 = 63, /* PID 0x56 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK2 = 64, /* PID 0x58 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK3 = 65, /* PID 0x56 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK4 = 66, /* PID 0x58 */
    RELATIVE_ACCELERATOR_PEDAL_POSITION = 67, /* PID 0x5A */
    HYBRID_BATTERY_PACK_REMAINING_LIFE = 68, /* PID 0x5B */
    FUEL_INJECTION_TIMING = 69, /* PID 0x5D */
    ENGINE_FUEL_RATE = 70, /* PID 0x5E */
    LAST_SYSTEM_INDEX = ENGINE_FUEL_RATE,
};

/**
 * This enum lists the types of supported VMS messages. It is used as the first
 * integer in the vehicle property integers array and determines how the rest of
 * the message is decoded.
 */
enum VmsMessageType : int32_t {
    /**
     * A request from the subscribers to the VMS service to subscribe to a layer.
     *
     * This message type uses enum VmsMessageWithLayerIntegerValuesIndex.
     */
    SUBSCRIBE = 1,

    /**
     * A request from the subscribers to the VMS service to subscribe to a layer from a specific publisher.
     *
     * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
     */
    SUBSCRIBE_TO_PUBLISHER = 2,

    /**
     * A request from the subscribers to the VMS service to unsubscribes from a layer.
     *
     * This message type uses enum VmsMessageWithLayerIntegerValuesIndex.
     */
    UNSUBSCRIBE = 3,

    /**
     * A request from the subscribers to the VMS service to unsubscribes from a layer from a specific publisher.
     *
     * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
     */
    UNSUBSCRIBE_TO_PUBLISHER = 4,

    /**
     * Information from the publishers to the VMS service about the layers which the client can publish.
     *
     * This message type uses enum VmsOfferingMessageIntegerValuesIndex.
     */
    OFFERING = 5,

    /**
     * A request from the subscribers to the VMS service to get the available layers.
     *
     * This message type uses enum VmsBaseMessageIntegerValuesIndex.
     */
    AVAILABILITY_REQUEST = 6,

    /**
     * A request from the publishers to the VMS service to get the layers with subscribers.
     *
     * This message type uses enum VmsBaseMessageIntegerValuesIndex.
     */
    SUBSCRIPTIONS_REQUEST = 7,

    /**
     * A response from the VMS service to the subscribers to a VmsMessageType.AVAILABILITY_REQUEST
     *
     * This message type uses enum VmsAvailabilityStateIntegerValuesIndex.
     */
    AVAILABILITY_RESPONSE = 8,

    /**
     * A notification from the VMS service to the subscribers on a change in the available layers.
     *
     * This message type uses enum VmsAvailabilityStateIntegerValuesIndex.
     */
    AVAILABILITY_CHANGE = 9,

    /**
     * A response from the VMS service to the publishers to a VmsMessageType.SUBSCRIPTIONS_REQUEST
     *
     * This message type uses enum VmsSubscriptionsStateIntegerValuesIndex.
     */
    SUBSCRIPTIONS_RESPONSE = 10,

    /**
     * A notification from the VMS service to the publishers on a change in the layers with subscribers.
     *
     * This message type uses enum VmsSubscriptionsStateIntegerValuesIndex.
     */
    SUBSCRIPTIONS_CHANGE = 11,

    /**
     * A message from the VMS service to the subscribers or from the publishers to the VMS service
     * with a serialized VMS data packet as defined in the VMS protocol.
     *
     * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
     */
    DATA = 12,

    /**
     * A request from the publishers to the VMS service to get a Publisher ID for a serialized VMS
     * provider description packet as defined in the VMS protocol.
     *
     * This message type uses enum VmsBaseMessageIntegerValuesIndex.
     */
    PUBLISHER_ID_REQUEST = 13,

    /**
     * A response from the VMS service to the publisher that contains a provider description packet
     * and the publisher ID assigned to it.
     *
     * This message type uses enum VmsPublisherInformationIntegerValuesIndex.
     */
    PUBLISHER_ID_RESPONSE = 14,

    /**
     * A request from the subscribers to the VMS service to get information for a Publisher ID.
     *
     * This message type uses enum VmsPublisherInformationIntegerValuesIndex.
     */
    PUBLISHER_INFORMATION_REQUEST = 15,

    /**
     * A response from the VMS service to the subscribers that contains a provider description packet
     * and the publisher ID assigned to it.
     *
     * This message type uses enum VmsPublisherInformationIntegerValuesIndex.
     */
    PUBLISHER_INFORMATION_RESPONSE = 16,

    LAST_VMS_MESSAGE_TYPE = PUBLISHER_INFORMATION_RESPONSE,
};

/**
 * Every VMS message starts with the type of the message from the VmsMessageType enum.
 * Messages with no parameters such as VmsMessageType.AVAILABILITY_REQUEST,
 * VmsMessageType.SUBSCRIPTIONS_REQUEST and VmsMessageType.DATA are also based on this enum.
 */
enum VmsBaseMessageIntegerValuesIndex : int32_t {
    /* The message type as enumerated by VmsMessageType enum. */
    MESSAGE_TYPE = 0,
};

/*
 * A VMS message with a layer is sent as part of a VmsMessageType.SUBSCRIBE or
 * VmsMessageType.UNSUBSCRIBE messages.
 *
 * The layer type is defined in the VMS protocol, and the subtype and version are
 * controlled by the implementer of the publisher.
 */
enum VmsMessageWithLayerIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    LAYER_TYPE = 1,
    LAYER_SUBTYPE = 2,
    LAYER_VERSION = 3,
};

/*
 * A VMS message with a layer and publisher ID is sent as part of a
 * VmsMessageType.SUBSCRIBE_TO_PUBLISHER, VmsMessageType.UNSUBSCRIBE_TO_PUBLISHER messages and
 * VmsMessageType.DATA .
 */
enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex : VmsMessageWithLayerIntegerValuesIndex {
    PUBLISHER_ID = 4,
};

/*
 * An offering can be sent by publishers as part of VmsMessageType.OFFERING in order to
 * advertise which layers they can publish and under which constraints: e.g., I can publish Layer X
 * if someone else will publish Layer Y.
 * The offering contains the publisher ID which was assigned to the publisher by the VMS service.
 * A single offering is represented as:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of dependencies (N)
 * - N x (Layer type, Layer subtype, Layer version)
 */
enum VmsOfferingMessageIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    PUBLISHER_ID = 1,
    NUMBER_OF_OFFERS = 2,
    OFFERING_START = 3,
};

/**
 * A subscriptions state is sent to the publishers in response to a change in the subscriptions
 * as part of a VmsMessageType.SUBSCRIPTIONS_CHANGE, or in response to a
 * VmsMessageType.SUBSCRIPTIONS_REQUEST message as part of VmsMessageType.SUBSCRIPTIONS_RESPONSE.
 * The VMS service issues monotonically increasing sequence numbers, and in case a subscriber receives
 * a smaller sequnce number it should ignore the message.
 * The subscriptions are sent as a list of layers followed by a list of associated layers:
 * {Sequence number, N, M, N x layer, M x associated layer}
 * A subscribed layer is represented as three integers:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * A subscribed associated layer is a layer with a list of publisher IDs. It is represented as:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of publisher IDs (N)
 * - N x publisher ID
 */
enum VmsSubscriptionsStateIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    SEQUENCE_NUMBER = 1,
    NUMBER_OF_LAYERS = 2,
    NUMBER_OF_ASSOCIATED_LAYERS = 3,
    SUBSCRIPTIONS_START = 4,
};

/**
 * An availability state is sent to the subscribers in response to a change in the available
 * layers as part of a VmsMessageType.AVAILABILITY_CHANGE message, or in response to a
 * VmsMessageType.AVAILABILITY_REQUEST message as part of a VmsMessageType.AVAILABILITY_RESPONSE.
 * The VMS service issues monotonically increasing sequence numbers, and in case a subscriber receives
 * a smaller sequnce number, it should ignore the message.
 * An available associated layer is a layer with a list of publisher IDs:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of publisher IDs (N)
 * - N x publisher ID
*/
enum VmsAvailabilityStateIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    SEQUENCE_NUMBER = 1,
    NUMBER_OF_ASSOCIATED_LAYERS = 2,
    LAYERS_START = 3,
};

/*
 * Publishers send the VMS service their information and assigned in response a publisher ID.
 * Subscribers can request the publisher information for a publisher ID they received in other messages.
 */
enum VmsPublisherInformationIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    PUBLISHER_ID = 1,
};

