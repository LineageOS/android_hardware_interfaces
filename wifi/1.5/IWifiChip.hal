/*
 * Copyright 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.wifi@1.5;

import @1.0::WifiStatus;
import @1.0::IfaceType;
import @1.5::IWifiApIface;
import @1.0::IWifiIface;
import @1.3::IWifiChip;
import @1.4::IWifiChip;

/**
 * Interface that represents a chip that must be configured as a single unit.
 */
interface IWifiChip extends @1.4::IWifiChip {
    /**
     * Capabilities exposed by this chip.
     */
    enum ChipCapabilityMask : @1.3::IWifiChip.ChipCapabilityMask {
        /**
         * chip can operate in the 60GHz band(WiGig chip)
         */
        WIGIG = 1 << 14,
    };

    /**
     * When there are 2 or more simultaneous STA connections, this use case hint indicates what
     * use-case is being enabled by the framework. This use case hint can be used by the firmware
     * to modify various firmware configurations like:
     *   - Allowed BSSIDs the firmware can choose for the initial connection/roaming attempts.
     *   - Duty cycle to choose for the 2 STA connections if the radio is in MCC mode.
     *   - Whether roaming, APF and other offloads needs to be enabled or not.
     * Note:
     *   - This will be invoked before an active wifi connection is established on the second
     *     interface.
     *   - This use-case hint is implicitly void when the second STA interface is brought down.
     */
    enum MultiStaUseCase : uint8_t {
        /**
         * Usage:
         * - This will be sent down for make before break use-case.
         * - Platform is trying to speculatively connect to a second network and evaluate it without
         *  disrupting the primary connection.
         * Requirements for Firmware:
         * - Do not reduce the number of tx/rx chains of primary connection.
         * - If using MCC, should set the MCC duty cycle of the primary connection to be higher than
         *  the secondary connection (maybe 70/30 split).
         * - Should pick the best BSSID for the secondary STA (disregard the chip mode) independent
         *   of the primary STA:
         *    - Don’t optimize for DBS vs MCC/SCC
         * - Should not impact the primary connection’s bssid selection:
         *    - Don’t downgrade chains of the existing primary connection.
         *    - Don’t optimize for DBS vs MCC/SCC.
         */
        DUAL_STA_TRANSIENT_PREFER_PRIMARY = 0,
        /**
         * Usage:
         * - This will be sent down for any app requested peer to peer connections.
         * - In this case, both the connections needs to be allocated equal resources.
         * - For the peer to peer use case, BSSID for the secondary connection will be chosen by the
         *   framework.
         *
         * Requirements for Firmware:
         * - Can choose MCC or DBS mode depending on the MCC efficiency and HW capability.
         * - If using MCC, set the MCC duty cycle of the primary connection to be equal to the
         *   secondary connection.
         * - Prefer BSSID candidates which will help provide the best "overall" performance for both
         *   the connections.
         */
        DUAL_STA_NON_TRANSIENT_UNBIASED = 1,
    };

    /**
     * Get the capabilities supported by this chip.
     *
     * @return status WifiStatus of the operation.
     *         Possible status codes:
     *         |WifiStatusCode.SUCCESS|,
     *         |WifiStatusCode.ERROR_WIFI_CHIP_INVALID|,
     *         |WifiStatusCode.ERROR_NOT_AVAILABLE|,
     *         |WifiStatusCode.ERROR_UNKNOWN|
     * @return capabilities Bitset of |ChipCapabilityMask| values.
     */
    getCapabilities_1_5()
        generates (WifiStatus status, bitfield<ChipCapabilityMask> capabilities);

    /**
     * Invoked to indicate that the provided iface is the primary STA iface when there are more
     * than 1 STA iface concurrently active.
     * Note: If the wifi firmware/chip cannot support multiple instances of any offload
     * (like roaming, APF, rssi threshold, etc), the firmware should ensure that these
     * offloads are at least enabled for the primary interface. If the new primary interface is
     * already connected to a network, the firmware must switch all the offloads on
     * this new interface without disconnecting.
     *
     * @param ifname Name of the STA iface.
     * @return status WifiStatus of the operation.
     *         Possible status codes:
     *         |WifiStatusCode.SUCCESS|,
     *         |WifiStatusCode.ERROR_WIFI_CHIP_INVALID|,
     *         |WifiStatusCode.ERROR_INVALID_ARGS|
     */
    setMultiStaPrimaryConnection(string ifName) generates (WifiStatus status);

    /**
     * Invoked to indicate the STA + STA use-case that is active.
     *
     * Refer to documentation of |MultiStaUseCase| for details.
     *
     * @param useCase Use case that is active.
     * @return status WifiStatus of the operation.
     *         Possible status codes:
     *         |WifiStatusCode.SUCCESS|,
     *         |WifiStatusCode.ERROR_WIFI_CHIP_INVALID|,
     *         |WifiStatusCode.ERROR_INVALID_ARGS|
     */
    setMultiStaUseCase(MultiStaUseCase useCase) generates (WifiStatus status);

    /**
     * Create bridged IWifiApIface.
     *
     * Depending on the mode the chip is configured in, the interface creation
     * may fail (code: |ERROR_NOT_AVAILABLE|) if we've already reached the maximum
     * allowed (specified in |ChipIfaceCombination|) number of ifaces of the AP
     * type.
     *
     * @return status WifiStatus of the operation.
     *         Possible status codes:
     *         |WifiStatusCode.SUCCESS|,
     *         |WifiStatusCode.ERROR_WIFI_CHIP_INVALID|,
     *         |WifiStatusCode.ERROR_NOT_SUPPORTED|,
     *         |WifiStatusCode.ERROR_NOT_AVAILABLE|
     * @return iface HIDL interface object representing the iface if
     *         successful, null otherwise.
     */
    createBridgedApIface() generates (WifiStatus status, IWifiApIface iface);

    /**
     * Removes one of the instance on the AP Iface with the provided ifaceName and
     * ifaceInstanceName.
     *
     * Use the API: removeApIface with brIfaceName in the V1_0::WifiChip.hal to remove bridge Iface.
     *
     * @param brIfaceName Name of the bridged AP iface.
     * @param ifaceInstanceName Name of the instance. The empty instance is
     * invalid.
     * @return status WifiStatus of the operation.
     *         Possible status codes:
     *         |WifiStatusCode.SUCCESS|,
     *         |WifiStatusCode.ERROR_WIFI_CHIP_INVALID|,
     *         |WifiStatusCode.ERROR_INVALID_ARGS|,
     *         |WifiStatusCode.ERROR_NOT_AVAILABLE|
     */
    removeIfaceInstanceFromBridgedApIface(string brIfaceName, string ifaceInstanceName)
        generates (WifiStatus status);

    /**
     * Representation of a Wi-Fi channel for Wi-Fi coex channel avoidance.
     */
    struct CoexUnsafeChannel {
        /* The band of the channel */
        WifiBand band;
        /* The channel number */
        uint32_t channel;
        /** The power cap will be a maximum power value in dbm that is allowed to be transmitted by
            the chip on this channel. A value of PowerCapConstant.NO_POWER_CAP means no limitation
            on transmitted power is needed by the chip for this channel.
        */
        int32_t powerCapDbm;
    };

    enum PowerCapConstant : int32_t {
        NO_POWER_CAP = 0x7FFFFFFF,
    };

    /**
     * Invoked to indicate that the provided |CoexUnsafeChannels| should be avoided with the
     * specified restrictions.
     *
     * Channel avoidance is a suggestion and should be done on a best-effort approach. If a provided
     * channel is used, then the specified power cap should be applied.
     *
     * In addition, hard restrictions on the Wifi modes may be indicated by |IfaceType| bits
     * (STA, AP, P2P, NAN, etc) in the |restrictions| bitfield. If a hard restriction is provided,
     * then the channels should be completely avoided for the provided Wifi modes instead of by
     * best-effort.
     *
     * @param unsafeChannels List of |CoexUnsafeChannels| to avoid.
     * @param restrictions Bitset of |IfaceType| values indicating Wifi modes to completely avoid.
     * @return status WifiStatus of the operation.
     *         Possible status codes:
     *         |WifiStatusCode.SUCCESS|,
     *         |WifiStatusCode.ERROR_WIFI_CHIP_INVALID|,
     *         |WifiStatusCode.ERROR_INVALID_ARGS|,
     */
    setCoexUnsafeChannels(
        vec<CoexUnsafeChannel> unsafeChannels, bitfield<IfaceType> restrictions)
            generates (WifiStatus status);
};
